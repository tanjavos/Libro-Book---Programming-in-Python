\section{Ejercicios}

\begin{exercise}
Escribe la función \pythoninline{es\_primo} que recibe un número n como parámetro 
y verifica que el número sea primo o no y devuelve el booleano correspondiente. Utiliza la función para crear una comprehension de conjunto de los números positivos entre 100 y 200 que son primos.
\end{exercise}


\begin{exercise}
Imagina que tenemos un diccionario \pythoninline{gente} enlazando los nombres de personas y años de nacimiento. 

\begin{python}
gente = {"pepita": 1971,
         "andre": 2001,
         "maria": 1969,
         "anton": 1945,
         "bobby": 2018,
         "pepita": 1972,
         "mickey": 1999,
         "mini": 1959,
         "donald": 1935,
         "elsa": 1971,
         "anna": 2001,
         "rudolf": 1969,
         "pipa": 2010,
         "dylan": 1945,
         "marit": 1971,
         "pluto": 1999,
         "mars": 1959,
         "dagobert": 1935,
         "maria" : 1970,
         "bobby" : 2021,
         "mickey" : 1945
         }
\end{python}

Escribe 2 versiones de una funcion (\pythoninline{de_los_anyos1} y \pythoninline{de_los_anyos2}) que dado un diccionario como lo de arriba y dos años $a_1$ y $a_2$, devuelve un conjunto con los nombres que se han dado entre los años a1 y a2. La primera version tienes que hacer con bucles y la segunda con una comprehension.

\begin{python}
>>> de_los_anyos1(gente, 1969, 1975)
{'rudolf', 'marit', 'maria', 'elsa', 'pepa', 'pepita'}
>>> de_los_anyos2(gente, 1969, 1975)
{'rudolf', 'marit', 'maria', 'elsa', 'pepa', 'pepita'}
\end{python}

Después puedes hacer testing comparando las dos implementaciones:

\begin{python}
def test_de_los_anyos():
    assert (de_los_anyos1(gente, 1969, 2010) == de_los_anyos2(gente, 1969, 2010))
    assert (de_los_anyos1(gente, 2021, 2022) == de_los_anyos2(gente, 2021, 2022))
\end{python}

\end{exercise}


\begin{exercise}
Imagina que tenemos el siguiente conjunto de colores:

\begin{python}
colors = {"white", "azure", "pink", "purple", "blue", "green", 
"yellow", "orange", "red", "brown", "black", "grey"
 }
\end{python}

a) Escribe un set comprehension para el conjunto de colores
cuyo nombre contiene la letra a.

b) Escribe un set comprehension para el conjunto de colores
cuyo nombre contiene más de 5 caracteres.

\end{exercise}

\begin{exercise}
Escribir una función (\verb@filter_impares@) con su documentación y sus test que dado un conjunto, una lista o una tupla, devuelve un conjunto con solo los elementos pares de la entrada (i.e. los impares se han filtrado).
\end{exercise}


\begin{exercise}
Una librería para colores web es \url{https://pypi.org/project/webcolors/1.3/}. Se puede añadir fácilmente en Thonny en 
herramientas $\rightarrow$ manage packages $\rightarrow$ buscar webcolors. Despues podemos importar las siguientes dos funciones.

\begin{python}
from webcolors import name_to_hex, name_to_rgb
\end{python}

La función \pythoninline{name_to_hex} convierta a un nombre de color (tipo string) a un valor normalizado hexadecimal en formato string.

\begin{python}
>>> name_to_hex('white')
'#ffffff'
>>> name_to_hex("pink")
'#ffc0cb'
\end{python}

La función \pythoninline{name_to_rgb} convierta a un nombre de color (tipo string) a una {\em tupla contenedor} (en ingles {\em namedtuple}) de tipo 
\pythoninline{IntegerRGB} que consiste de 3 integers en el rango de [0,255] llamado 
\pythoninline{red}, \pythoninline{blue}  and \pythoninline{green}. Cada uno representa la parte de cada color (RGB) en el color que se esta convirtiendo.


\begin{python}
>>> name_to_rgb("white")
IntegerRGB(red=255, green=255, blue=255)
>>> name_to_rgb("white").red
255
>>> name_to_rgb("white").blue
255
>>> name_to_rgb("red")
IntegerRGB(red=255, green=0, blue=0)
\end{python}

a) Escribe un comprehension para el conjunto de colores
que NO tiene una nada de rojo.


b) Escribe un comprehension para el conjunto de colores
que tienen menos de 100 azul y más de 200 verde.
\end{exercise}




\begin{exercise}
Considerar el siguiente programa: 

\begin{small}
\begin{python}
def f(param):
    return (param == (1,2,3))
    
xs = {x for x in range(0,13) if f(x)}
print(xs)
\end{python}
\end{small} 

¿que sale?

a) \pythoninline{set()} %\CorrectChoice

b) \pythoninline{\{\}}

c) \pythoninline{(1, 2, 3)}

 d) \pythoninline{\{(1,2,3)\}}

\end{exercise}

\newpage 

\begin{exercise}
Considerar el siguiente programa: 

\begin{small}
\begin{python}
st = [12,33,64,12,59]
tt = [51,62,73,84]
rt = tt[0:6]
rt.append(9)
print(set(st)^set(rt))
print(set(rt)-set(tt))
\end{python}
\end{small} 

¿que puede salir?


a) 
\pythoninline{\{  64, 73, 9, 12, 84, 33, 51, 59, 62  \}}\\ %\CorrectChoice
    \pythoninline{\{  9  \}}

b)  
\pythoninline{set()}\\
    \pythoninline{\{ 73, 9, 51, 84, 62\}}

c)  
\pythoninline{\{ 73, 9, 51, 84, 62\}}\\
    \pythoninline{set()}

d)  IndexError: list index out of range

\end{exercise}




